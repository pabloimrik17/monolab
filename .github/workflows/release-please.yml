name: Release Please

on:
    push:
        branches:
            - main

permissions:
    contents: write
    issues: write
    pull-requests: write
    id-token: write

jobs:
    release-please:
        runs-on: ubuntu-latest
        outputs:
            releases_created: ${{ steps.release.outputs.releases_created }}
            paths_released: ${{ steps.release.outputs.paths_released }}
        steps:
            - uses: googleapis/release-please-action@v4
              id: release
              with:
                  # Use manifest mode for monorepo
                  config-file: release-please-config.json
                  manifest-file: .release-please-manifest.json
                  # Explicitly target main branch for release PRs
                  target-branch: main

    publish:
        needs: release-please
        runs-on: ubuntu-latest
        if: ${{ needs.release-please.outputs.releases_created == 'true' }}
        permissions:
            contents: read
            id-token: write
        env:
            NX_CLOUD_ACCESS_TOKEN: ${{ secrets.NX_CLOUD_ACCESS_TOKEN }}
            NX_NO_CLOUD: ${{ vars.NX_NO_CLOUD }}
        steps:
            - name: Checkout code
              uses: actions/checkout@v4

            - name: Setup pnpm
              uses: pnpm/action-setup@v4
              with:
                  version: 10.19.0

            - name: Setup Node.js
              uses: actions/setup-node@v4
              with:
                  node-version: "24.11.0"
                  cache: "pnpm"
                  registry-url: "https://registry.npmjs.org"

            - name: Setup Deno
              uses: denoland/setup-deno@v2
              with:
                  deno-version: v2.5.6

            - name: Install dependencies
              run: pnpm install --frozen-lockfile

            - name: Get released packages
              id: released-packages
              env:
                  PATHS_RELEASED: ${{ needs.release-please.outputs.paths_released }}
              run: |
                  # Parse paths_released to get package names (using env var to prevent script injection)
                  echo "Released paths: $PATHS_RELEASED"

                  # Extract package names from paths (packages/is-even -> is-even)
                  # Convert to space-separated single line for GitHub Actions output
                  PACKAGES=$(echo "$PATHS_RELEASED" | jq -r '.[] | select(startswith("packages/")) | sub("packages/"; "")' | tr '\n' ' ')
                  echo "packages=$PACKAGES" >> $GITHUB_OUTPUT
                  echo "Released packages: $PACKAGES"

            - name: Build and publish packages to npm
              run: |
                  # Get list of packages
                  PACKAGES="${{ steps.released-packages.outputs.packages }}"

                  # First, build and publish all packages to npm
                  for PKG_DIR in $PACKAGES; do
                    PKG_PATH="packages/$PKG_DIR"
                    PACKAGE_NAME="@m0n0lab/$PKG_DIR"

                    if [ ! -d "$PKG_PATH" ]; then
                      echo "Package directory $PKG_PATH not found, skipping..."
                      continue
                    fi

                    echo "Processing package: $PACKAGE_NAME"

                    # Build the package using Nx (NX_NO_CLOUD disables cloud)
                    echo "Building $PACKAGE_NAME..."
                    pnpm nx run $PKG_DIR:build

                    # Publish to npm using pnpm (transforms workspace:* to semver)
                    echo "Publishing $PACKAGE_NAME to npm..."
                    cd $PKG_PATH
                    pnpm publish --access public --no-git-checks
                    cd ../..

                    echo "Successfully published $PACKAGE_NAME to npm"
                  done

            - name: Publish packages to JSR
              run: |
                  # Get list of packages that were released
                  PACKAGES="${{ steps.released-packages.outputs.packages }}"

                  # Generate dependency graph to determine publish order (using --print to avoid creating files)
                  # Filter to only include library projects (excludes demo app) and sort by dependencies
                  ORDERED_PACKAGES=$(pnpm exec nx graph --print 2>/dev/null | jq -r '
                    .graph.dependencies |
                    to_entries |
                    map(select(.key | startswith("@m0n0lab/") and (contains("demo") | not))) |
                    map({
                      pkg: (.key | sub("@m0n0lab/"; "")),
                      deps: (.value | length)
                    }) |
                    sort_by(.deps) |
                    .[].pkg
                  ')

                  echo "Publishing to JSR in dependency order: $ORDERED_PACKAGES"

                  # Publish in dependency order
                  for PKG_DIR in $ORDERED_PACKAGES; do
                    # Only publish if package was released
                    if echo "$PACKAGES" | grep -q "$PKG_DIR"; then
                      PKG_PATH="packages/$PKG_DIR"
                      PACKAGE_NAME="@m0n0lab/$PKG_DIR"

                      echo "Publishing $PACKAGE_NAME to JSR..."
                      cd $PKG_PATH
                      deno publish --allow-dirty
                      cd ../..

                      echo "Successfully published $PACKAGE_NAME to JSR"
                    fi
                  done

            - name: Summary
              if: success()
              run: |
                  echo "âœ… All packages published successfully!" >> $GITHUB_STEP_SUMMARY
                  echo "" >> $GITHUB_STEP_SUMMARY
                  echo "Published packages:" >> $GITHUB_STEP_SUMMARY
                  echo "${{ steps.released-packages.outputs.packages }}" >> $GITHUB_STEP_SUMMARY
